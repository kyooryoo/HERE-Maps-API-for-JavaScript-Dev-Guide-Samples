<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.2/mapsjs-core.js"></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.2/mapsjs-service.js"></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.2/mapsjs-mapevents.js"></script>
    <script type="text/javascript" charset="utf-8" src="https://js.api.here.com/v3/3.2/mapsjs-ui.js"></script>
    <link rel="stylesheet" type="text/css" href="https://js.api.here.com/v3/3.2/mapsjs-ui.css" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <script type="text/javascript" src="../../credentials.js"></script>
</head>

<body>
    <div style="width: 100%; height: 700px" id="mapContainer"></div>
    <script>
        //BOILERPLATE CODE TO INITIALIZE THE MAP
        const platform = new H.service.Platform({
            'apikey': window.apikey
        });

        // Obtain the default map types from the platform object:
        const defaultLayers = platform.createDefaultLayers();

        // Instantiate (and display) a map:
        const map = new H.Map(
            document.getElementById("mapContainer"),
            defaultLayers.vector.normal.map, {
            zoom: 6,
            center: {
                lat: 53.480759,
                lng: -2.242631
            },
            padding: { top: 50, right: 50, bottom: 50, left: 50 },
        });

        // MapEvents enables the event system
        // Behavior implements default interactions for pan/zoom (also on mobile touch environments)
        const behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));

        // Disable zoom on double-tap to allow removing waypoints on double-tap
        behavior.disable(H.mapevents.Behavior.Feature.DBL_TAP_ZOOM);

        window.addEventListener('resize', () => map.getViewPort().resize());

        // Create the default UI:
        const ui = H.ui.UI.createDefault(map, defaultLayers);

        // ROUTING LOGIC STARTS HERE

        // This variable holds the instance of the route polyline
        let routePolyline;

        /**
         * Handler for the H.service.RoutingService#calculateRoute call
         *
         * @param {object} response The response object returned by calculateRoute method
         */
        function routeResponseHandler(response) {
            const sections = response.routes[0].sections;
            const lineStrings = [];
            sections.forEach((section) => {
                // convert Flexible Polyline encoded string to geometry
                lineStrings.push(H.geo.LineString.fromFlexiblePolyline(section.polyline));
            });
            const multiLineString = new H.geo.MultiLineString(lineStrings);
            const bounds = multiLineString.getBoundingBox();

            // Create the polyline for the route
            if (routePolyline) {
                // If the routePolyline we just set has the new geometry
                routePolyline.setGeometry(multiLineString);
            } else {
                // If routePolyline is not yet defined, instantiate a new H.map.Polyline
                routePolyline = new H.map.Polyline(multiLineString, {
                    style: {
                        lineWidth: 5
                    }
                });
            }

            // Add the polyline to the map
            map.addObject(routePolyline);

            // Set the map viewport to make the entire route visible:
            map.getViewModel().setLookAtData({
                bounds: routePolyline.getBoundingBox(),
            });
        }

        /**
         * Returns an instance of H.map.Icon to style the markers
         * @param {number|string} id An identifier that will be displayed as marker label
         *
         * @return {H.map.Icon}
         */
        function getMarkerIcon(id) {
            const svgCircle = `<svg width="30" height="30" version="1.1" xmlns="http://www.w3.org/2000/svg">
                <g id="marker">
                    <circle cx="15" cy="15" r="10" fill="#E80808" stroke="#D31010" stroke-width="2" />
                    <text x="50%" y="50%" text-anchor="middle" fill="#FFFFFF" font-family="Arial, sans-serif" font-size="12px" dy=".3em">${id}</text>
                </g></svg>`;
            return new H.map.Icon(svgCircle, {
                anchor: {
                    x: 10,
                    y: 10
                }
            });
        }

        /**
         * Create an instance of H.map.Marker and add it to the map
         *
         * @param {object} position  An object with 'lat' and 'lng' properties defining the position of the marker
         * @param {string|number} id An identifier that will be displayed as marker label
         * @return {H.map.Marker} The instance of the marker that was created
         */
        function addMarker(position, id) {
            const marker = new H.map.Marker(position, {
                data: {
                    id
                },
                icon: getMarkerIcon(id),
                // Enable smooth dragging
                volatility: true
            });

            // Enable draggable markers
            marker.draggable = true;

            map.addObject(marker);
            return marker;
        }

        /**
         * This method calls the routing service to retrieve the route line geometry
         */
        function updateRoute() {
            routingParams.via = new H.service.Url.MultiValueQueryParameter(
                waypoints.map(wp => `${wp.getGeometry().lat},${wp.getGeometry().lng}`));

            // Call the routing service with the defined parameters
            router.calculateRoute(routingParams, routeResponseHandler, console.error);
        }

        // ADD MARKERS FOR ORIGIN/DESTINATION
        const origin = {
            lat: 52.643233,
            lng: 13.30395
        }; // Starting point
        const destination = {
            lat: 52.37688,
            lng: 13.56038
        }; // Destination point

        const originMarker = addMarker(origin, 'S');
        const destinationMarker = addMarker(destination, 'D');

        // CALCULATE THE ROUTE BETWEEN THE TWO WAYPOINTS
        // This array holds instances of H.map.Marker representing the route waypoints
        const waypoints = []

        // Define the routing service parameters
        const routingParams = {
            'origin': `${origin.lat},${origin.lng}`,
            'destination': `${destination.lat},${destination.lng}`,
            // defines multiple waypoints
            'via': new H.service.Url.MultiValueQueryParameter(waypoints),
            'transportMode': 'car',
            'return': 'polyline'
        };

        // Get an instance of the H.service.RoutingService service
        const router = platform.getRoutingService();

        // Call the routing service with the defined parameters and display the route
        updateRoute();

        /**
         * Listen to the dragstart and store relevant position information of the marker
         */
        map.addEventListener('dragstart', function (ev) {
            const target = ev.target;
            const pointer = ev.currentPointer;
            if (target instanceof H.map.Marker) {
                // Disable the default draggability of the underlying map
                behavior.disable(H.mapevents.Behavior.Feature.PANNING);

                const targetPosition = map.geoToScreen(target.getGeometry());
                // Calculate the offset between mouse and target's position
                // when starting to drag a marker object
                target['offset'] = new H.math.Point(
                    pointer.viewportX - targetPosition.x, pointer.viewportY - targetPosition.y);
            }
        }, false);

        /**
         * Listen to the dragend and update the route
         */
        map.addEventListener('dragend', function (ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker) {
                // re-enable the default draggability of the underlying map
                // when dragging has completed
                behavior.enable(H.mapevents.Behavior.Feature.PANNING);
                const coords = target.getGeometry();
                const markerId = target.getData().id;

                // Update the routing params `origin` and `destination` properties
                // in case we dragging either the origin or the destination marker
                if (markerId === 'A') {
                    routingParams.origin = `${coords.lat},${coords.lng}`;
                } else if (markerId === 'B') {
                    routingParams.destination = `${coords.lat},${coords.lng}`;
                }

                updateRoute();
            }
        }, false);

        /**
         * Listen to the drag event and move the position of the marker as necessary
         */
        map.addEventListener('drag', function (ev) {
            const target = ev.target;
            const pointer = ev.currentPointer;
            if (target instanceof H.map.Marker) {
                target.setGeometry(
                    map.screenToGeo(pointer.viewportX - target['offset'].x, pointer.viewportY - target['offset'].y)
                );
            }
        }, false);

        /**
         * Listen to the tap event to add a new waypoint
         */
        map.addEventListener('tap', function (ev) {
            const target = ev.target;
            const pointer = ev.currentPointer;
            const coords = map.screenToGeo(pointer.viewportX, pointer.viewportY);

            if (!(target instanceof H.map.Marker)) {
                const marker = addMarker(coords, waypoints.length + 1);
                waypoints.push(marker);
                updateRoute();
            }
        });

        /**
         * Listen to the dbltap event to remove a waypoint
         */
        map.addEventListener('dbltap', function (ev) {
            const target = ev.target;

            if (target instanceof H.map.Marker) {
                // Prevent origin or destination markers from being removed
                if (['origin', 'destination'].indexOf(target.getData().id) !== -1) {
                    return;
                }

                const markerIdx = waypoints.indexOf(target);
                if (markerIdx !== -1) {
                    // Remove the marker from the array of way points
                    waypoints.splice(markerIdx, 1)
                    // Iterate over the remaining waypoints and update their data
                    waypoints.forEach((marker, idx) => {
                        const id = idx + 1;
                        // Update marker's id
                        marker.setData({
                            id
                        });
                        // Update marker's icon to show its new id
                        marker.setIcon(getMarkerIcon(id))
                    });
                }

                // Remove the marker from the map
                map.removeObject(target);

                updateRoute();
            }
        });

    </script>
</body>

</html>